/**
 * –ü—Ä–æ—Ñ–∞–π–ª–µ—Ä –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
 * –ò–∑–º–µ—Ä—è–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —ç—Ç–∞–ø–æ–≤ –∞–Ω–∞–ª–∏–∑–∞
 * –∏ –≤—ã—è–≤–ª—è–µ—Ç —É–∑–∫–∏–µ –º–µ—Å—Ç–∞ –≤ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
 */

export interface TimingMeasurement {
  name: string;
  startTime: number;
  endTime: number;
  duration: number;
  phase: string;
  metadata?: Record<string, any>;
}

export interface PerformanceProfileResult {
  measurements: TimingMeasurement[];
  totalDuration: number;
  phases: PhaseAnalysis[];
  bottlenecks: Bottleneck[];
  recommendations: string[];
  efficiency: {
    score: number;
    grade: 'A' | 'B' | 'C' | 'D' | 'F';
    description: string;
  };
}

export interface PhaseAnalysis {
  phase: string;
  totalDuration: number;
  averageDuration: number;
  operationCount: number;
  percentage: number;
  slowestOperation: TimingMeasurement;
}

export interface Bottleneck {
  operation: string;
  duration: number;
  percentage: number;
  severity: 'low' | 'medium' | 'high' | 'critical';
  recommendation: string;
}

export class ExecutionTimer {
  private measurements: TimingMeasurement[] = [];
  private activeTimers = new Map<
    string,
    { startTime: number; phase: string; metadata?: Record<string, any> }
  >();
  private phaseStack: string[] = [];
  private isActive = false;

  /**
   * –ó–∞–ø—É—Å–∫–∞–µ—Ç –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
   */
  startProfiling(): void {
    this.isActive = true;
    this.measurements = [];
    this.activeTimers.clear();
    this.phaseStack = [];
  }

  /**
   * –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
   */
  stopProfiling(): void {
    this.isActive = false;

    // –ó–∞–≤–µ—Ä—à–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–∞–π–º–µ—Ä—ã
    for (const [name] of this.activeTimers) {
      this.endTimer(name);
    }
  }

  /**
   * –í—Ö–æ–¥–∏—Ç –≤ –Ω–æ–≤—É—é —Ñ–∞–∑—É –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
   */
  enterPhase(phaseName: string): void {
    if (!this.isActive) return;

    this.phaseStack.push(phaseName);
    this.startTimer(`phase_${phaseName}`, phaseName);
  }

  /**
   * –í—ã—Ö–æ–¥–∏—Ç –∏–∑ —Ç–µ–∫—É—â–µ–π —Ñ–∞–∑—ã
   */
  exitPhase(): string | null {
    if (!this.isActive || this.phaseStack.length === 0) return null;

    const phase = this.phaseStack.pop()!;
    this.endTimer(`phase_${phase}`);
    return phase;
  }

  /**
   * –ó–∞–ø—É—Å–∫–∞–µ—Ç —Ç–∞–π–º–µ—Ä –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–∏
   */
  startTimer(name: string, phase?: string, metadata?: Record<string, any>): void {
    if (!this.isActive) return;

    const currentPhase = phase || this.getCurrentPhase();

    this.activeTimers.set(name, {
      startTime: performance.now(),
      phase: currentPhase,
      metadata,
    });
  }

  /**
   * –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ç–∞–π–º–µ—Ä –∏ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –∏–∑–º–µ—Ä–µ–Ω–∏–µ
   */
  endTimer(name: string): number {
    if (!this.isActive) return 0;

    const timer = this.activeTimers.get(name);
    if (!timer) {
      console.warn(`Timer "${name}" –Ω–µ –±—ã–ª –∑–∞–ø—É—â–µ–Ω`);
      return 0;
    }

    const endTime = performance.now();
    const duration = endTime - timer.startTime;

    const measurement: TimingMeasurement = {
      name,
      startTime: timer.startTime,
      endTime,
      duration,
      phase: timer.phase,
      metadata: timer.metadata,
    };

    this.measurements.push(measurement);
    this.activeTimers.delete(name);

    return duration;
  }

  /**
   * –ò–∑–º–µ—Ä—è–µ—Ç –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏
   */
  async measureFunction<T>(
    name: string,
    fn: () => Promise<T>,
    phase?: string,
    metadata?: Record<string, any>
  ): Promise<T> {
    this.startTimer(name, phase, metadata);
    try {
      const result = await fn();
      return result;
    } finally {
      this.endTimer(name);
    }
  }

  /**
   * –ò–∑–º–µ—Ä—è–µ—Ç –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
   */
  measureSync<T>(name: string, fn: () => T, phase?: string, metadata?: Record<string, any>): T {
    this.startTimer(name, phase, metadata);
    try {
      const result = fn();
      return result;
    } finally {
      this.endTimer(name);
    }
  }

  /**
   * –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
   */
  analyzeProfile(): PerformanceProfileResult {
    if (this.measurements.length === 0) {
      return this.getEmptyResult();
    }

    const totalDuration = this.calculateTotalDuration();
    const phases = this.analyzePhases();
    const bottlenecks = this.detectBottlenecks(totalDuration);
    const recommendations = this.generateRecommendations(phases, bottlenecks);
    const efficiency = this.calculateEfficiency(phases, bottlenecks);

    return {
      measurements: this.measurements,
      totalDuration,
      phases,
      bottlenecks,
      recommendations,
      efficiency,
    };
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ñ–∞–∑—É –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
   */
  private getCurrentPhase(): string {
    return this.phaseStack.length > 0 ? this.phaseStack[this.phaseStack.length - 1] : 'default';
  }

  /**
   * –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –æ–±—â–µ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
   */
  private calculateTotalDuration(): number {
    const phaseMeasurements = this.measurements.filter(m => m.name.startsWith('phase_'));

    if (phaseMeasurements.length === 0) {
      return this.measurements.reduce((total, m) => total + m.duration, 0);
    }

    return (
      Math.max(...phaseMeasurements.map(m => m.endTime)) -
      Math.min(...phaseMeasurements.map(m => m.startTime))
    );
  }

  /**
   * –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ —Ñ–∞–∑–∞–º
   */
  private analyzePhases(): PhaseAnalysis[] {
    const phaseGroups = new Map<string, TimingMeasurement[]>();

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –∏–∑–º–µ—Ä–µ–Ω–∏—è –ø–æ —Ñ–∞–∑–∞–º
    for (const measurement of this.measurements) {
      if (!phaseGroups.has(measurement.phase)) {
        phaseGroups.set(measurement.phase, []);
      }
      phaseGroups.get(measurement.phase)!.push(measurement);
    }

    const totalDuration = this.calculateTotalDuration();
    const phases: PhaseAnalysis[] = [];

    for (const [phase, measurements] of phaseGroups) {
      const phaseTotalDuration = measurements.reduce((sum, m) => sum + m.duration, 0);
      const averageDuration = phaseTotalDuration / measurements.length;
      const slowestOperation = measurements.reduce((slowest, current) =>
        current.duration > slowest.duration ? current : slowest
      );

      phases.push({
        phase,
        totalDuration: Math.round(phaseTotalDuration * 100) / 100,
        averageDuration: Math.round(averageDuration * 100) / 100,
        operationCount: measurements.length,
        percentage: Math.round((phaseTotalDuration / totalDuration) * 100 * 100) / 100,
        slowestOperation,
      });
    }

    return phases.sort((a, b) => b.totalDuration - a.totalDuration);
  }

  /**
   * –û–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç —É–∑–∫–∏–µ –º–µ—Å—Ç–∞ –≤ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
   */
  private detectBottlenecks(totalDuration: number): Bottleneck[] {
    const bottlenecks: Bottleneck[] = [];

    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    const sortedMeasurements = [...this.measurements].sort((a, b) => b.duration - a.duration);

    for (const measurement of sortedMeasurements) {
      const percentage = (measurement.duration / totalDuration) * 100;

      if (percentage < 5) break; // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏ –º–µ–Ω–µ–µ 5% –≤—Ä–µ–º–µ–Ω–∏

      let severity: Bottleneck['severity'];
      let recommendation: string;

      if (percentage > 40) {
        severity = 'critical';
        recommendation = `–ö–†–ò–¢–ò–ß–ù–û: –û–ø–µ—Ä–∞—Ü–∏—è ${measurement.name} –∑–∞–Ω–∏–º–∞–µ—Ç ${percentage.toFixed(1)}% –≤—Ä–µ–º–µ–Ω–∏. –¢—Ä–µ–±—É–µ—Ç –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏.`;
      } else if (percentage > 25) {
        severity = 'high';
        recommendation = `–û–ø–µ—Ä–∞—Ü–∏—è ${measurement.name} –∑–∞–Ω–∏–º–∞–µ—Ç ${percentage.toFixed(1)}% –≤—Ä–µ–º–µ–Ω–∏. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è.`;
      } else if (percentage > 15) {
        severity = 'medium';
        recommendation = `–û–ø–µ—Ä–∞—Ü–∏—è ${measurement.name} –∑–∞–Ω–∏–º–∞–µ—Ç ${percentage.toFixed(1)}% –≤—Ä–µ–º–µ–Ω–∏. –ú–æ–∂–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å.`;
      } else {
        severity = 'low';
        recommendation = `–û–ø–µ—Ä–∞—Ü–∏—è ${measurement.name} –∑–∞–Ω–∏–º–∞–µ—Ç ${percentage.toFixed(1)}% –≤—Ä–µ–º–µ–Ω–∏. –ü—Ä–∏–µ–º–ª–µ–º–æ, –Ω–æ –µ—Å—Ç—å –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è.`;
      }

      bottlenecks.push({
        operation: measurement.name,
        duration: Math.round(measurement.duration * 100) / 100,
        percentage: Math.round(percentage * 100) / 100,
        severity,
        recommendation,
      });
    }

    return bottlenecks;
  }

  /**
   * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
   */
  private generateRecommendations(phases: PhaseAnalysis[], bottlenecks: Bottleneck[]): string[] {
    const recommendations: string[] = [];

    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–±—â–µ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    const criticalBottlenecks = bottlenecks.filter(b => b.severity === 'critical');
    const highBottlenecks = bottlenecks.filter(b => b.severity === 'high');

    if (criticalBottlenecks.length > 0) {
      recommendations.push(
        'üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï —É–∑–∫–∏–µ –º–µ—Å—Ç–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã! –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–±—É–µ—Ç—Å—è.'
      );
    }

    if (highBottlenecks.length > 0) {
      recommendations.push('‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã —Å–µ—Ä—å–µ–∑–Ω—ã–µ —É–∑–∫–∏–µ –º–µ—Å—Ç–∞. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è.');
    }

    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Ñ–∞–∑–∞–º
    const slowestPhase = phases[0];
    if (slowestPhase && slowestPhase.percentage > 50) {
      recommendations.push(
        `üìä –§–∞–∑–∞ "${slowestPhase.phase}" –∑–∞–Ω–∏–º–∞–µ—Ç ${slowestPhase.percentage}% –≤—Ä–µ–º–µ–Ω–∏. –°—Ñ–æ–∫—É—Å–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ –µ—ë –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏.`
      );
    }

    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –ø–∞—Ç—Ç–µ—Ä–Ω–∞–º
    const shortOperations = this.measurements.filter(m => m.duration < 1).length;
    const totalOperations = this.measurements.length;

    if (shortOperations / totalOperations > 0.8) {
      recommendations.push('üí° –ú–Ω–æ–≥–æ –º–µ–ª–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π. –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫—É –∏–ª–∏ –±–∞—Ç—á–∏–Ω–≥.');
    }

    // –û–±—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
    if (recommendations.length === 0) {
      recommendations.push('‚úÖ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ –Ω–æ—Ä–º–µ. –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ.');
    }

    return recommendations;
  }

  /**
   * –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
   */
  private calculateEfficiency(
    phases: PhaseAnalysis[],
    bottlenecks: Bottleneck[]
  ): PerformanceProfileResult['efficiency'] {
    let score = 100;

    // –®—Ç—Ä–∞—Ñ—ã –∑–∞ —É–∑–∫–∏–µ –º–µ—Å—Ç–∞
    const criticalBottlenecks = bottlenecks.filter(b => b.severity === 'critical').length;
    const highBottlenecks = bottlenecks.filter(b => b.severity === 'high').length;
    const mediumBottlenecks = bottlenecks.filter(b => b.severity === 'medium').length;

    score -= criticalBottlenecks * 30;
    score -= highBottlenecks * 15;
    score -= mediumBottlenecks * 8;

    // –®—Ç—Ä–∞—Ñ –∑–∞ –Ω–µ—Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞–≥—Ä—É–∑–∫–∏
    if (phases.length > 0) {
      const maxPhasePercentage = Math.max(...phases.map(p => p.percentage));
      if (maxPhasePercentage > 70) score -= 20;
      else if (maxPhasePercentage > 50) score -= 10;
    }

    score = Math.max(0, score);

    let grade: 'A' | 'B' | 'C' | 'D' | 'F';
    let description: string;

    if (score >= 90) {
      grade = 'A';
      description = '–û—Ç–ª–∏—á–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å';
    } else if (score >= 80) {
      grade = 'B';
      description = '–•–æ—Ä–æ—à–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å';
    } else if (score >= 70) {
      grade = 'C';
      description = '–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å';
    } else if (score >= 60) {
      grade = 'D';
      description = '–ü–ª–æ—Ö–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å';
    } else {
      grade = 'F';
      description = '–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏';
    }

    return { score, grade, description };
  }

  /**
   * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
   */
  private getEmptyResult(): PerformanceProfileResult {
    return {
      measurements: [],
      totalDuration: 0,
      phases: [],
      bottlenecks: [],
      recommendations: ['–ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ –ø—Ä–æ–≤–æ–¥–∏–ª–æ—Å—å'],
      efficiency: {
        score: 0,
        grade: 'F',
        description: '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞',
      },
    };
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–µ–∫—É—â–∏—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–∞–π–º–µ—Ä–æ–≤
   */
  getActiveTimersStats(): { count: number; names: string[]; phases: string[] } {
    const names = Array.from(this.activeTimers.keys());
    const phases = [...new Set(Array.from(this.activeTimers.values()).map(t => t.phase))];

    return {
      count: this.activeTimers.size,
      names,
      phases,
    };
  }

  /**
   * –û—á–∏—â–∞–µ—Ç –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏—è
   */
  reset(): void {
    this.measurements = [];
    this.activeTimers.clear();
    this.phaseStack = [];
    this.isActive = false;
  }
}
